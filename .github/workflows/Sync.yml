/**
 * syncOpenseaOrders.js
 * OpenSea kolleksiyanƒ±zdakƒ± NFT-l…ôri Seaport order-larƒ± il…ô backend-…ô …ôlav…ô edir
 * Node.js ‚â•18 v…ô ya node-fetch t…ôl…ôb olunur
 */
// --- CONFIG ---
const BACKEND_URL = "https://s…ônin-app.onrender.com"; // Sizin backend URL
const NFT_CONTRACT_ADDRESS = "0x54a88333F6e7540eA982261301309048aC431eD5";
const PROXY_CONTRACT_ADDRESS = "0x9656448941C76B79A39BC4ad68f6fb9F01181EC7"; // <- …ôlav…ô olundu
const PAGE_SIZE = 50; // OpenSea API limit
const OPENSEA_API_KEY = ""; // ƒ∞st…ôs…ôniz OpenSea API Key qoyun rate-limit √º√ß√ºn

// --- HELPERS ---
async function fetchOpenseaAssets(offset = 0) {
  const url = `https://api.opensea.io/api/v1/assets?asset_contract_address=${NFT_CONTRACT_ADDRESS}&order_direction=desc&offset=${offset}&limit=${PAGE_SIZE}`;

  const headers = { "Accept": "application/json" };
  if (OPENSEA_API_KEY) headers["X-API-KEY"] = OPENSEA_API_KEY;

  try {
    const res = await fetch(url, { headers });
    if (!res.ok) {
      console.error("OpenSea API error:", res.status, res.statusText);
      return [];
    }
    const data = await res.json();
    return data.assets || [];
  } catch (err) {
    console.error("Fetch OpenSea failed:", err);
    return [];
  }
}

async function postOrderToBackend(order) {
  try {
    const res = await fetch(`${BACKEND_URL}/order`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(order),
    });
    const data = await res.json();
    if (!data.success) console.error("Backend error:", data);
    else console.log("‚úÖ Order added:", order.tokenId);
  } catch (err) {
    console.error("POST /order failed:", err);
  }
}

// --- MAIN SYNC LOOP ---
async function main() {
  console.log("üöÄ Sync started...");
  let offset = 0;

  while (true) {
    const assets = await fetchOpenseaAssets(offset);
    if (!assets.length) break;

    for (const nft of assets) {
      if (!nft.sell_orders || !nft.sell_orders.length) continue;

      for (const order of nft.sell_orders) {
        if (!order.protocol_data?.parameters) continue;

        const payload = {
          tokenId: nft.token_id,
          price: order.current_price ? parseFloat(order.current_price) / 1e18 : 0,
          sellerAddress: order.maker?.address || "unknown",
          seaportOrder: order.protocol_data,
          orderHash: order.order_hash || null,
          image: nft.image_url || nft.metadata?.image || null,
          marketplaceContract: PROXY_CONTRACT_ADDRESS // <- buraya …ôlav…ô etdik
        };

        await postOrderToBackend(payload);
      }
    }

    offset += PAGE_SIZE;
  }

  console.log("‚úÖ Sync tamamlandƒ±!");
}

// --- RUN ---
main().catch(err => {
  console.error("Sync fatal error:", err);
});
